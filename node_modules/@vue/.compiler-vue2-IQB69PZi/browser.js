(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VueTemplateCompiler = {}));
})(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var splitRE$1 = /\r?\n/g;
	var emptyRE = /^\s*$/;
	var needFixRE = /^(\r?\n)*[\t\s]/;

	var deIndent = function deindent (str) {
	  if (!needFixRE.test(str)) {
	    return str
	  }
	  var lines = str.split(splitRE$1);
	  var min = Infinity;
	  var type, cur, c;
	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];
	    if (!emptyRE.test(line)) {
	      if (!type) {
	        c = line.charAt(0);
	        if (c === ' ' || c === '\t') {
	          type = c;
	          cur = count(line, type);
	          if (cur < min) {
	            min = cur;
	          }
	        } else {
	          return str
	        }
	      } else {
	        cur = count(line, type);
	        if (cur < min) {
	          min = cur;
	        }
	      }
	    }
	  }
	  return lines.map(function (line) {
	    return line.slice(min)
	  }).join('\n')
	};

	function count (line, type) {
	  var i = 0;
	  while (line.charAt(i) === type) {
	    i++;
	  }
	  return i
	}

	var emptyObject = Object.freeze({});
	var isArray = Array.isArray;
	// These helpers produce better VM code in JS engines due to their
	// explicitness and function inlining.
	function isUndef(v) {
	    return v === undefined || v === null;
	}
	function isDef(v) {
	    return v !== undefined && v !== null;
	}
	function isTrue(v) {
	    return v === true;
	}
	function isFalse(v) {
	    return v === false;
	}
	/**
	 * Check if value is primitive.
	 */
	function isPrimitive(value) {
	    return (typeof value === 'string' ||
	        typeof value === 'number' ||
	        // $flow-disable-line
	        typeof value === 'symbol' ||
	        typeof value === 'boolean');
	}
	function isFunction(value) {
	    return typeof value === 'function';
	}
	/**
	 * Quick object check - this is primarily used to tell
	 * objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject(obj) {
	    return obj !== null && typeof obj === 'object';
	}
	/**
	 * Get the raw type string of a value, e.g., [object Object].
	 */
	var _toString = Object.prototype.toString;
	function toRawType(value) {
	    return _toString.call(value).slice(8, -1);
	}
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	function isPlainObject(obj) {
	    return _toString.call(obj) === '[object Object]';
	}
	/**
	 * Check if val is a valid array index.
	 */
	function isValidArrayIndex(val) {
	    var n = parseFloat(String(val));
	    return n >= 0 && Math.floor(n) === n && isFinite(val);
	}
	function isPromise(val) {
	    return (isDef(val) &&
	        typeof val.then === 'function' &&
	        typeof val.catch === 'function');
	}
	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function toString(val) {
	    return val == null
	        ? ''
	        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
	            ? JSON.stringify(val, replacer, 2)
	            : String(val);
	}
	function replacer(_key, val) {
	    // avoid circular deps from v3
	    if (val && val.__v_isRef) {
	        return val.value;
	    }
	    return val;
	}
	/**
	 * Convert an input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber(val) {
	    var n = parseFloat(val);
	    return isNaN(n) ? val : n;
	}
	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap(str, expectsLowerCase) {
	    var map = Object.create(null);
	    var list = str.split(',');
	    for (var i = 0; i < list.length; i++) {
	        map[list[i]] = true;
	    }
	    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };
	}
	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);
	/**
	 * Check if an attribute is a reserved attribute.
	 */
	var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
	/**
	 * Check whether an object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	    return hasOwnProperty.call(obj, key);
	}
	/**
	 * Create a cached version of a pure function.
	 */
	function cached(fn) {
	    var cache = Object.create(null);
	    return function cachedFn(str) {
	        var hit = cache[str];
	        return hit || (cache[str] = fn(str));
	    };
	}
	/**
	 * Camelize a hyphen-delimited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
	});
	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	    return str.charAt(0).toUpperCase() + str.slice(1);
	});
	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /\B([A-Z])/g;
	var hyphenate = cached(function (str) {
	    return str.replace(hyphenateRE, '-$1').toLowerCase();
	});
	/**
	 * Mix properties into target object.
	 */
	function extend(to, _from) {
	    for (var key in _from) {
	        to[key] = _from[key];
	    }
	    return to;
	}
	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject(arr) {
	    var res = {};
	    for (var i = 0; i < arr.length; i++) {
	        if (arr[i]) {
	            extend(res, arr[i]);
	        }
	    }
	    return res;
	}
	/* eslint-disable no-unused-vars */
	/**
	 * Perform no operation.
	 * Stubbing args to make Flow happy without leaving useless transpiled code
	 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
	 */
	function noop(a, b, c) { }
	/**
	 * Always return false.
	 */
	var no = function (a, b, c) { return false; };
	/* eslint-enable no-unused-vars */
	/**
	 * Return the same value.
	 */
	var identity = function (_) { return _; };
	/**
	 * Generate a string containing static keys from compiler modules.
	 */
	function genStaticKeys$1(modules) {
	    return modules
	        .reduce(function (keys, m) { return keys.concat(m.staticKeys || []); }, [])
	        .join(',');
	}
	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual(a, b) {
	    if (a === b)
	        return true;
	    var isObjectA = isObject(a);
	    var isObjectB = isObject(b);
	    if (isObjectA && isObjectB) {
	        try {
	            var isArrayA = Array.isArray(a);
	            var isArrayB = Array.isArray(b);
	            if (isArrayA && isArrayB) {
	                return (a.length === b.length &&
	                    a.every(function (e, i) {
	                        return looseEqual(e, b[i]);
	                    }));
	            }
	            else if (a instanceof Date && b instanceof Date) {
	                return a.getTime() === b.getTime();
	            }
	            else if (!isArrayA && !isArrayB) {
	                var keysA = Object.keys(a);
	                var keysB = Object.keys(b);
	                return (keysA.length === keysB.length &&
	                    keysA.every(function (key) {
	                        return looseEqual(a[key], b[key]);
	                    }));
	            }
	            else {
	                /* istanbul ignore next */
	                return false;
	            }
	        }
	        catch (e) {
	            /* istanbul ignore next */
	            return false;
	        }
	    }
	    else if (!isObjectA && !isObjectB) {
	        return String(a) === String(b);
	    }
	    else {
	        return false;
	    }
	}
	/**
	 * Return the first index at which a loosely equal value can be
	 * found in the array (if value is a plain object, the array must
	 * contain an object of the same shape), or -1 if it is not present.
	 */
	function looseIndexOf(arr, val) {
	    for (var i = 0; i < arr.length; i++) {
	        if (looseEqual(arr[i], val))
	            return i;
	    }
	    return -1;
	}
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
	function hasChanged(x, y) {
	    if (x === y) {
	        return x === 0 && 1 / x !== 1 / y;
	    }
	    else {
	        return x === x || y === y;
	    }
	}

	var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
	    'link,meta,param,source,track,wbr');
	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
	    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
	    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
	    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
	    'title,tr,track');

	/**
	 * unicode letters used for parsing html tags, component names and property paths.
	 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
	 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
	 */
	var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
	/**
	 * Define a property.
	 */
	function def(obj, key, val, enumerable) {
	    Object.defineProperty(obj, key, {
	        value: val,
	        enumerable: !!enumerable,
	        writable: true,
	        configurable: true
	    });
	}

	/**
	 * Not type-checking this file because it's mostly vendor code.
	 */
	// Regular Expressions for parsing tags and attributes
	var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
	var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
	var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(unicodeRegExp.source, "]*");
	var qnameCapture = "((?:".concat(ncname, "\\:)?").concat(ncname, ")");
	var startTagOpen = new RegExp("^<".concat(qnameCapture));
	var startTagClose = /^\s*(\/?)>/;
	var endTag = new RegExp("^<\\/".concat(qnameCapture, "[^>]*>"));
	var doctype = /^<!DOCTYPE [^>]+>/i;
	// #7298: escape - to avoid being passed as HTML comment when inlined in page
	var comment = /^<!\--/;
	var conditionalComment = /^<!\[/;
	// Special Elements (can contain anything)
	var isPlainTextElement = makeMap('script,style,textarea', true);
	var reCache = {};
	var decodingMap = {
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&amp;': '&',
	    '&#10;': '\n',
	    '&#9;': '\t',
	    '&#39;': "'"
	};
	var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
	var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;
	// #5992
	var isIgnoreNewlineTag = makeMap('pre,textarea', true);
	var shouldIgnoreFirstNewline = function (tag, html) {
	    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
	};
	function decodeAttr(value, shouldDecodeNewlines) {
	    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
	    return value.replace(re, function (match) { return decodingMap[match]; });
	}
	function parseHTML(html, options) {
	    var stack = [];
	    var expectHTML = options.expectHTML;
	    var isUnaryTag = options.isUnaryTag || no;
	    var canBeLeftOpenTag = options.canBeLeftOpenTag || no;
	    var index = 0;
	    var last, lastTag;
	    var _loop_1 = function () {
	        last = html;
	        // Make sure we're not in a plaintext content element like script/style
	        if (!lastTag || !isPlainTextElement(lastTag)) {
	            var textEnd = html.indexOf('<');
	            if (textEnd === 0) {
	                // Comment:
	                if (comment.test(html)) {
	                    var commentEnd = html.indexOf('-->');
	                    if (commentEnd >= 0) {
	                        if (options.shouldKeepComment && options.comment) {
	                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
	                        }
	                        advance(commentEnd + 3);
	                        return "continue";
	                    }
	                }
	                // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	                if (conditionalComment.test(html)) {
	                    var conditionalEnd = html.indexOf(']>');
	                    if (conditionalEnd >= 0) {
	                        advance(conditionalEnd + 2);
	                        return "continue";
	                    }
	                }
	                // Doctype:
	                var doctypeMatch = html.match(doctype);
	                if (doctypeMatch) {
	                    advance(doctypeMatch[0].length);
	                    return "continue";
	                }
	                // End tag:
	                var endTagMatch = html.match(endTag);
	                if (endTagMatch) {
	                    var curIndex = index;
	                    advance(endTagMatch[0].length);
	                    parseEndTag(endTagMatch[1], curIndex, index);
	                    return "continue";
	                }
	                // Start tag:
	                var startTagMatch = parseStartTag();
	                if (startTagMatch) {
	                    handleStartTag(startTagMatch);
	                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
	                        advance(1);
	                    }
	                    return "continue";
	                }
	            }
	            var text = void 0, rest = void 0, next = void 0;
	            if (textEnd >= 0) {
	                rest = html.slice(textEnd);
	                while (!endTag.test(rest) &&
	                    !startTagOpen.test(rest) &&
	                    !comment.test(rest) &&
	                    !conditionalComment.test(rest)) {
	                    // < in plain text, be forgiving and treat it as text
	                    next = rest.indexOf('<', 1);
	                    if (next < 0)
	                        break;
	                    textEnd += next;
	                    rest = html.slice(textEnd);
	                }
	                text = html.substring(0, textEnd);
	            }
	            if (textEnd < 0) {
	                text = html;
	            }
	            if (text) {
	                advance(text.length);
	            }
	            if (options.chars && text) {
	                options.chars(text, index - text.length, index);
	            }
	        }
	        else {
	            var endTagLength_1 = 0;
	            var stackedTag_1 = lastTag.toLowerCase();
	            var reStackedTag = reCache[stackedTag_1] ||
	                (reCache[stackedTag_1] = new RegExp('([\\s\\S]*?)(</' + stackedTag_1 + '[^>]*>)', 'i'));
	            var rest = html.replace(reStackedTag, function (all, text, endTag) {
	                endTagLength_1 = endTag.length;
	                if (!isPlainTextElement(stackedTag_1) && stackedTag_1 !== 'noscript') {
	                    text = text
	                        .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
	                        .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	                }
	                if (shouldIgnoreFirstNewline(stackedTag_1, text)) {
	                    text = text.slice(1);
	                }
	                if (options.chars) {
	                    options.chars(text);
	                }
	                return '';
	            });
	            index += html.length - rest.length;
	            html = rest;
	            parseEndTag(stackedTag_1, index - endTagLength_1, index);
	        }
	        if (html === last) {
	            options.chars && options.chars(html);
	            if (!stack.length && options.warn) {
	                options.warn("Mal-formatted tag at end of template: \"".concat(html, "\""), {
	                    start: index + html.length
	                });
	            }
	            return "break";
	        }
	    };
	    while (html) {
	        var state_1 = _loop_1();
	        if (state_1 === "break")
	            break;
	    }
	    // Clean up any remaining tags
	    parseEndTag();
	    function advance(n) {
	        index += n;
	        html = html.substring(n);
	    }
	    function parseStartTag() {
	        var start = html.match(startTagOpen);
	        if (start) {
	            var match = {
	                tagName: start[1],
	                attrs: [],
	                start: index
	            };
	            advance(start[0].length);
	            var end = void 0, attr = void 0;
	            while (!(end = html.match(startTagClose)) &&
	                (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
	                attr.start = index;
	                advance(attr[0].length);
	                attr.end = index;
	                match.attrs.push(attr);
	            }
	            if (end) {
	                match.unarySlash = end[1];
	                advance(end[0].length);
	                match.end = index;
	                return match;
	            }
	        }
	    }
	    function handleStartTag(match) {
	        var tagName = match.tagName;
	        var unarySlash = match.unarySlash;
	        if (expectHTML) {
	            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
	                parseEndTag(lastTag);
	            }
	            if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
	                parseEndTag(tagName);
	            }
	        }
	        var unary = isUnaryTag(tagName) || !!unarySlash;
	        var l = match.attrs.length;
	        var attrs = new Array(l);
	        for (var i = 0; i < l; i++) {
	            var args = match.attrs[i];
	            var value = args[3] || args[4] || args[5] || '';
	            var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
	                ? options.shouldDecodeNewlinesForHref
	                : options.shouldDecodeNewlines;
	            attrs[i] = {
	                name: args[1],
	                value: decodeAttr(value, shouldDecodeNewlines)
	            };
	            if (options.outputSourceRange) {
	                attrs[i].start = args.start + args[0].match(/^\s*/).length;
	                attrs[i].end = args.end;
	            }
	        }
	        if (!unary) {
	            stack.push({
	                tag: tagName,
	                lowerCasedTag: tagName.toLowerCase(),
	                attrs: attrs,
	                start: match.start,
	                end: match.end
	            });
	            lastTag = tagName;
	        }
	        if (options.start) {
	            options.start(tagName, attrs, unary, match.start, match.end);
	        }
	    }
	    function parseEndTag(tagName, start, end) {
	        var pos, lowerCasedTagName;
	        if (start == null)
	            start = index;
	        if (end == null)
	            end = index;
	        // Find the closest opened tag of the same type
	        if (tagName) {
	            lowerCasedTagName = tagName.toLowerCase();
	            for (pos = stack.length - 1; pos >= 0; pos--) {
	                if (stack[pos].lowerCasedTag === lowerCasedTagName) {
	                    break;
	                }
	            }
	        }
	        else {
	            // If no tag name is provided, clean shop
	            pos = 0;
	        }
	        if (pos >= 0) {
	            // Close all the open elements, up the stack
	            for (var i = stack.length - 1; i >= pos; i--) {
	                if ((i > pos || !tagName) && options.warn) {
	                    options.warn("tag <".concat(stack[i].tag, "> has no matching end tag."), {
	                        start: stack[i].start,
	                        end: stack[i].end
	                    });
	                }
	                if (options.end) {
	                    options.end(stack[i].tag, start, end);
	                }
	            }
	            // Remove the open elements from the stack
	            stack.length = pos;
	            lastTag = pos && stack[pos - 1].tag;
	        }
	        else if (lowerCasedTagName === 'br') {
	            if (options.start) {
	                options.start(tagName, [], true, start, end);
	            }
	        }
	        else if (lowerCasedTagName === 'p') {
	            if (options.start) {
	                options.start(tagName, [], false, start, end);
	            }
	            if (options.end) {
	                options.end(tagName, start, end);
	            }
	        }
	    }
	}

	var DEFAULT_FILENAME = 'anonymous.vue';
	var splitRE = /\r?\n/g;
	var replaceRE = /./g;
	var isSpecialTag = makeMap('script,style,template', true);
	/**
	 * Parse a single-file component (*.vue) file into an SFC Descriptor Object.
	 */
	function parseComponent(source, options) {
	    if (options === void 0) { options = {}; }
	    var sfc = {
	        source: source,
	        filename: DEFAULT_FILENAME,
	        template: null,
	        script: null,
	        scriptSetup: null,
	        styles: [],
	        customBlocks: [],
	        cssVars: [],
	        errors: [],
	        shouldForceReload: null // attached in parse() by compiler-sfc
	    };
	    var depth = 0;
	    var currentBlock = null;
	    var warn = function (msg) {
	        sfc.errors.push(msg);
	    };
	    if (options.outputSourceRange) {
	        warn = function (msg, range) {
	            var data = { msg: msg };
	            if (range.start != null) {
	                data.start = range.start;
	            }
	            if (range.end != null) {
	                data.end = range.end;
	            }
	            sfc.errors.push(data);
	        };
	    }
	    function start(tag, attrs, unary, start, end) {
	        if (depth === 0) {
	            currentBlock = {
	                type: tag,
	                content: '',
	                start: end,
	                end: 0,
	                attrs: attrs.reduce(function (cumulated, _a) {
	                    var name = _a.name, value = _a.value;
	                    cumulated[name] = value || true;
	                    return cumulated;
	                }, {})
	            };
	            if (typeof currentBlock.attrs.src === 'string') {
	                currentBlock.src = currentBlock.attrs.src;
	            }
	            if (isSpecialTag(tag)) {
	                checkAttrs(currentBlock, attrs);
	                if (tag === 'script') {
	                    var block = currentBlock;
	                    if (block.attrs.setup) {
	                        block.setup = currentBlock.attrs.setup;
	                        sfc.scriptSetup = block;
	                    }
	                    else {
	                        sfc.script = block;
	                    }
	                }
	                else if (tag === 'style') {
	                    sfc.styles.push(currentBlock);
	                }
	                else {
	                    sfc[tag] = currentBlock;
	                }
	            }
	            else {
	                // custom blocks
	                sfc.customBlocks.push(currentBlock);
	            }
	        }
	        if (!unary) {
	            depth++;
	        }
	    }
	    function checkAttrs(block, attrs) {
	        for (var i = 0; i < attrs.length; i++) {
	            var attr = attrs[i];
	            if (attr.name === 'lang') {
	                block.lang = attr.value;
	            }
	            if (attr.name === 'scoped') {
	                block.scoped = true;
	            }
	            if (attr.name === 'module') {
	                block.module = attr.value || true;
	            }
	        }
	    }
	    function end(tag, start) {
	        if (depth === 1 && currentBlock) {
	            currentBlock.end = start;
	            var text = source.slice(currentBlock.start, currentBlock.end);
	            if (options.deindent === true ||
	                // by default, deindent unless it's script with default lang or (j/t)sx?
	                (options.deindent !== false &&
	                    !(currentBlock.type === 'script' &&
	                        (!currentBlock.lang || /^(j|t)sx?$/.test(currentBlock.lang))))) {
	                text = deIndent(text);
	            }
	            // pad content so that linters and pre-processors can output correct
	            // line numbers in errors and warnings
	            if (currentBlock.type !== 'template' && options.pad) {
	                text = padContent(currentBlock, options.pad) + text;
	            }
	            currentBlock.content = text;
	            currentBlock = null;
	        }
	        depth--;
	    }
	    function padContent(block, pad) {
	        if (pad === 'space') {
	            return source.slice(0, block.start).replace(replaceRE, ' ');
	        }
	        else {
	            var offset = source.slice(0, block.start).split(splitRE).length;
	            var padChar = block.type === 'script' && !block.lang ? '//\n' : '\n';
	            return Array(offset).join(padChar);
	        }
	    }
	    parseHTML(source, {
	        warn: warn,
	        start: start,
	        end: end,
	        outputSourceRange: options.outputSourceRange
	    });
	    return sfc;
	}

	// can we use __proto__?
	var hasProto = '__proto__' in {};
	// Browser environment sniffing
	var inBrowser = typeof window !== 'undefined';
	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	UA && UA.indexOf('android') > 0;
	UA && /iphone|ipad|ipod|ios/.test(UA);
	UA && /chrome\/\d+/.test(UA) && !isEdge;
	UA && /phantomjs/.test(UA);
	UA && UA.match(/firefox\/(\d+)/);
	// Firefox has a "watch" function on Object.prototype...
	// @ts-expect-error firebox support
	var nativeWatch = {}.watch;
	var supportsPassive = false;
	if (inBrowser) {
	    try {
	        var opts = {};
	        Object.defineProperty(opts, 'passive', {
	            get: function () {
	                /* istanbul ignore next */
	                supportsPassive = true;
	            }
	        }); // https://github.com/facebook/flow/issues/285
	        window.addEventListener('test-passive', null, opts);
	    }
	    catch (e) { }
	}
	// this needs to be lazy-evaled because vue may be required before
	// vue-server-renderer can set VUE_ENV
	var _isServer;
	var isServerRendering = function () {
	    if (_isServer === undefined) {
	        /* istanbul ignore if */
	        if (!inBrowser && typeof global !== 'undefined') {
	            // detect presence of vue-server-renderer and avoid
	            // Webpack shimming the process
	            _isServer =
	                global['process'] && global['process'].env.VUE_ENV === 'server';
	        }
	        else {
	            _isServer = false;
	        }
	    }
	    return _isServer;
	};
	/* istanbul ignore next */
	function isNative(Ctor) {
	    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
	}
	var hasSymbol = typeof Symbol !== 'undefined' &&
	    isNative(Symbol) &&
	    typeof Reflect !== 'undefined' &&
	    isNative(Reflect.ownKeys);
	var _Set; // $flow-disable-line
	/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
	    // use native Set when available.
	    _Set = Set;
	}
	else {
	    // a non-standard Set polyfill that only works with primitive keys.
	    _Set = /** @class */ (function () {
	        function Set() {
	            this.set = Object.create(null);
	        }
	        Set.prototype.has = function (key) {
	            return this.set[key] === true;
	        };
	        Set.prototype.add = function (key) {
	            this.set[key] = true;
	        };
	        Set.prototype.clear = function () {
	            this.set = Object.create(null);
	        };
	        return Set;
	    }());
	}

	var ASSET_TYPES = ['component', 'directive', 'filter'];
	var LIFECYCLE_HOOKS = [
	    'beforeCreate',
	    'created',
	    'beforeMount',
	    'mounted',
	    'beforeUpdate',
	    'updated',
	    'beforeDestroy',
	    'destroyed',
	    'activated',
	    'deactivated',
	    'errorCaptured',
	    'serverPrefetch',
	    'renderTracked',
	    'renderTriggered'
	];

	var config = {
	    /**
	     * Option merge strategies (used in core/util/options)
	     */
	    // $flow-disable-line
	    optionMergeStrategies: Object.create(null),
	    /**
	     * Whether to suppress warnings.
	     */
	    silent: false,
	    /**
	     * Show production mode tip message on boot?
	     */
	    productionTip: true,
	    /**
	     * Whether to enable devtools
	     */
	    devtools: true,
	    /**
	     * Whether to record perf
	     */
	    performance: false,
	    /**
	     * Error handler for watcher errors
	     */
	    errorHandler: null,
	    /**
	     * Warn handler for watcher warns
	     */
	    warnHandler: null,
	    /**
	     * Ignore certain custom elements
	     */
	    ignoredElements: [],
	    /**
	     * Custom user key aliases for v-on
	     */
	    // $flow-disable-line
	    keyCodes: Object.create(null),
	    /**
	     * Check if a tag is reserved so that it cannot be registered as a
	     * component. This is platform-dependent and may be overwritten.
	     */
	    isReservedTag: no,
	    /**
	     * Check if an attribute is reserved so that it cannot be used as a component
	     * prop. This is platform-dependent and may be overwritten.
	     */
	    isReservedAttr: no,
	    /**
	     * Check if a tag is an unknown element.
	     * Platform-dependent.
	     */
	    isUnknownElement: no,
	    /**
	     * Get the namespace of an element
	     */
	    getTagNamespace: noop,
	    /**
	     * Parse the real tag name for the specific platform.
	     */
	    parsePlatformTagName: identity,
	    /**
	     * Check if an attribute must be bound using property, e.g. value
	     * Platform-dependent.
	     */
	    mustUseProp: no,
	    /**
	     * Perform updates asynchronously. Intended to be used by Vue Test Utils
	     * This will significantly reduce performance if set to false.
	     */
	    async: true,
	    /**
	     * Exposed for legacy reasons
	     */
	    _lifecycleHooks: LIFECYCLE_HOOKS
	};

	var currentInstance = null;
	/**
	 * @internal
	 */
	function setCurrentInstance(vm) {
	    if (vm === void 0) { vm = null; }
	    if (!vm)
	        currentInstance && currentInstance._scope.off();
	    currentInstance = vm;
	    vm && vm._scope.on();
	}

	/**
	 * @internal
	 */
	var VNode = /** @class */ (function () {
	    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
	        this.tag = tag;
	        this.data = data;
	        this.children = children;
	        this.text = text;
	        this.elm = elm;
	        this.ns = undefined;
	        this.context = context;
	        this.fnContext = undefined;
	        this.fnOptions = undefined;
	        this.fnScopeId = undefined;
	        this.key = data && data.key;
	        this.componentOptions = componentOptions;
	        this.componentInstance = undefined;
	        this.parent = undefined;
	        this.raw = false;
	        this.isStatic = false;
	        this.isRootInsert = true;
	        this.isComment = false;
	        this.isCloned = false;
	        this.isOnce = false;
	        this.asyncFactory = asyncFactory;
	        this.asyncMeta = undefined;
	        this.isAsyncPlaceholder = false;
	    }
	    Object.defineProperty(VNode.prototype, "child", {
	        // DEPRECATED: alias for componentInstance for backwards compat.
	        /* istanbul ignore next */
	        get: function () {
	            return this.componentInstance;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return VNode;
	}());
	var createEmptyVNode = function (text) {
	    if (text === void 0) { text = ''; }
	    var node = new VNode();
	    node.text = text;
	    node.isComment = true;
	    return node;
	};
	function createTextVNode(val) {
	    return new VNode(undefined, undefined, undefined, String(val));
	}
	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode(vnode) {
	    var cloned = new VNode(vnode.tag, vnode.data, 
	    // #7975
	    // clone children array to avoid mutating original in case of cloning
	    // a child.
	    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
	    cloned.ns = vnode.ns;
	    cloned.isStatic = vnode.isStatic;
	    cloned.key = vnode.key;
	    cloned.isComment = vnode.isComment;
	    cloned.fnContext = vnode.fnContext;
	    cloned.fnOptions = vnode.fnOptions;
	    cloned.fnScopeId = vnode.fnScopeId;
	    cloned.asyncMeta = vnode.asyncMeta;
	    cloned.isCloned = true;
	    return cloned;
	}

	/* not type checking this file because flow doesn't play well with Proxy */
	{
	    makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
	        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
	        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
	        'require' // for Webpack/Browserify
	    );
	    var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);
	    if (hasProxy_1) {
	        var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
	        config.keyCodes = new Proxy(config.keyCodes, {
	            set: function (target, key, value) {
	                if (isBuiltInModifier_1(key)) {
	                    warn$2("Avoid overwriting built-in modifier in config.keyCodes: .".concat(key));
	                    return false;
	                }
	                else {
	                    target[key] = value;
	                    return true;
	                }
	            }
	        });
	    }
	}

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	var uid = 0;
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 * @internal
	 */
	var Dep = /** @class */ (function () {
	    function Dep() {
	        // pending subs cleanup
	        this._pending = false;
	        this.id = uid++;
	        this.subs = [];
	    }
	    Dep.prototype.addSub = function (sub) {
	        this.subs.push(sub);
	    };
	    Dep.prototype.removeSub = function (sub) {
	        // #12696 deps with massive amount of subscribers are extremely slow to
	        // clean up in Chromium
	        // to workaround this, we unset the sub for now, and clear them on
	        // next scheduler flush.
	        this.subs[this.subs.indexOf(sub)] = null;
	        if (!this._pending) {
	            this._pending = true;
	        }
	    };
	    Dep.prototype.depend = function (info) {
	        if (Dep.target) {
	            Dep.target.addDep(this);
	            if (info && Dep.target.onTrack) {
	                Dep.target.onTrack(__assign({ effect: Dep.target }, info));
	            }
	        }
	    };
	    Dep.prototype.notify = function (info) {
	        // stabilize the subscriber list first
	        var subs = this.subs.filter(function (s) { return s; });
	        for (var i = 0, l = subs.length; i < l; i++) {
	            var sub = subs[i];
	            if (info) {
	                sub.onTrigger &&
	                    sub.onTrigger(__assign({ effect: subs[i] }, info));
	            }
	            sub.update();
	        }
	    };
	    return Dep;
	}());
	// The current target watcher being evaluated.
	// This is globally unique because only one watcher
	// can be evaluated at a time.
	Dep.target = null;
	var targetStack = [];
	function pushTarget(target) {
	    targetStack.push(target);
	    Dep.target = target;
	}
	function popTarget() {
	    targetStack.pop();
	    Dep.target = targetStack[targetStack.length - 1];
	}

	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */
	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);
	var methodsToPatch = [
	    'push',
	    'pop',
	    'shift',
	    'unshift',
	    'splice',
	    'sort',
	    'reverse'
	];
	/**
	 * Intercept mutating methods and emit events
	 */
	methodsToPatch.forEach(function (method) {
	    // cache original method
	    var original = arrayProto[method];
	    def(arrayMethods, method, function mutator() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var result = original.apply(this, args);
	        var ob = this.__ob__;
	        var inserted;
	        switch (method) {
	            case 'push':
	            case 'unshift':
	                inserted = args;
	                break;
	            case 'splice':
	                inserted = args.slice(2);
	                break;
	        }
	        if (inserted)
	            ob.observeArray(inserted);
	        // notify change
	        {
	            ob.dep.notify({
	                type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
	                target: this,
	                key: method
	            });
	        }
	        return result;
	    });
	});

	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
	var NO_INITIAL_VALUE = {};
	/**
	 * In some cases we may want to disable observation inside a component's
	 * update computation.
	 */
	var shouldObserve = true;
	function toggleObserving(value) {
	    shouldObserve = value;
	}
	// ssr mock dep
	var mockDep = {
	    notify: noop,
	    depend: noop,
	    addSub: noop,
	    removeSub: noop
	};
	/**
	 * Observer class that is attached to each observed
	 * object. Once attached, the observer converts the target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatch updates.
	 */
	var Observer = /** @class */ (function () {
	    function Observer(value, shallow, mock) {
	        if (shallow === void 0) { shallow = false; }
	        if (mock === void 0) { mock = false; }
	        this.value = value;
	        this.shallow = shallow;
	        this.mock = mock;
	        // this.value = value
	        this.dep = mock ? mockDep : new Dep();
	        this.vmCount = 0;
	        def(value, '__ob__', this);
	        if (isArray(value)) {
	            if (!mock) {
	                if (hasProto) {
	                    value.__proto__ = arrayMethods;
	                    /* eslint-enable no-proto */
	                }
	                else {
	                    for (var i = 0, l = arrayKeys.length; i < l; i++) {
	                        var key = arrayKeys[i];
	                        def(value, key, arrayMethods[key]);
	                    }
	                }
	            }
	            if (!shallow) {
	                this.observeArray(value);
	            }
	        }
	        else {
	            /**
	             * Walk through all properties and convert them into
	             * getter/setters. This method should only be called when
	             * value type is Object.
	             */
	            var keys = Object.keys(value);
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock);
	            }
	        }
	    }
	    /**
	     * Observe a list of Array items.
	     */
	    Observer.prototype.observeArray = function (value) {
	        for (var i = 0, l = value.length; i < l; i++) {
	            observe(value[i], false, this.mock);
	        }
	    };
	    return Observer;
	}());
	// helpers
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe(value, shallow, ssrMockReactivity) {
	    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	        return value.__ob__;
	    }
	    if (shouldObserve &&
	        (ssrMockReactivity || !isServerRendering()) &&
	        (isArray(value) || isPlainObject(value)) &&
	        Object.isExtensible(value) &&
	        !value.__v_skip /* ReactiveFlags.SKIP */ &&
	        !isRef(value) &&
	        !(value instanceof VNode)) {
	        return new Observer(value, shallow, ssrMockReactivity);
	    }
	}
	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive(obj, key, val, customSetter, shallow, mock, observeEvenIfShallow) {
	    if (observeEvenIfShallow === void 0) { observeEvenIfShallow = false; }
	    var dep = new Dep();
	    var property = Object.getOwnPropertyDescriptor(obj, key);
	    if (property && property.configurable === false) {
	        return;
	    }
	    // cater for pre-defined getter/setters
	    var getter = property && property.get;
	    var setter = property && property.set;
	    if ((!getter || setter) &&
	        (val === NO_INITIAL_VALUE || arguments.length === 2)) {
	        val = obj[key];
	    }
	    var childOb = shallow ? val && val.__ob__ : observe(val, false, mock);
	    Object.defineProperty(obj, key, {
	        enumerable: true,
	        configurable: true,
	        get: function reactiveGetter() {
	            var value = getter ? getter.call(obj) : val;
	            if (Dep.target) {
	                {
	                    dep.depend({
	                        target: obj,
	                        type: "get" /* TrackOpTypes.GET */,
	                        key: key
	                    });
	                }
	                if (childOb) {
	                    childOb.dep.depend();
	                    if (isArray(value)) {
	                        dependArray(value);
	                    }
	                }
	            }
	            return isRef(value) && !shallow ? value.value : value;
	        },
	        set: function reactiveSetter(newVal) {
	            var value = getter ? getter.call(obj) : val;
	            if (!hasChanged(value, newVal)) {
	                return;
	            }
	            if (customSetter) {
	                customSetter();
	            }
	            if (setter) {
	                setter.call(obj, newVal);
	            }
	            else if (getter) {
	                // #7981: for accessor properties without setter
	                return;
	            }
	            else if (!shallow && isRef(value) && !isRef(newVal)) {
	                value.value = newVal;
	                return;
	            }
	            else {
	                val = newVal;
	            }
	            childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock);
	            {
	                dep.notify({
	                    type: "set" /* TriggerOpTypes.SET */,
	                    target: obj,
	                    key: key,
	                    newValue: newVal,
	                    oldValue: value
	                });
	            }
	        }
	    });
	    return dep;
	}
	function set(target, key, val) {
	    if ((isUndef(target) || isPrimitive(target))) {
	        warn$2("Cannot set reactive property on undefined, null, or primitive value: ".concat(target));
	    }
	    if (isReadonly(target)) {
	        warn$2("Set operation on key \"".concat(key, "\" failed: target is readonly."));
	        return;
	    }
	    var ob = target.__ob__;
	    if (isArray(target) && isValidArrayIndex(key)) {
	        target.length = Math.max(target.length, key);
	        target.splice(key, 1, val);
	        // when mocking for SSR, array methods are not hijacked
	        if (ob && !ob.shallow && ob.mock) {
	            observe(val, false, true);
	        }
	        return val;
	    }
	    if (key in target && !(key in Object.prototype)) {
	        target[key] = val;
	        return val;
	    }
	    if (target._isVue || (ob && ob.vmCount)) {
	        warn$2('Avoid adding reactive properties to a Vue instance or its root $data ' +
	                'at runtime - declare it upfront in the data option.');
	        return val;
	    }
	    if (!ob) {
	        target[key] = val;
	        return val;
	    }
	    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
	    {
	        ob.dep.notify({
	            type: "add" /* TriggerOpTypes.ADD */,
	            target: target,
	            key: key,
	            newValue: val,
	            oldValue: undefined
	        });
	    }
	    return val;
	}
	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray(value)